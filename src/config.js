/**
 * Project configuration
 * This file is auto-generated by pipecat-cli
 */

export const AVAILABLE_TRANSPORTS = [
  'daily',
  'smallwebrtc',
];

const environment = import.meta.env.VITE_ENVIRONMENT || 'local';

export const DEFAULT_TRANSPORT = environment === 'local' ? 'smallwebrtc' : 'daily';

const botStartUrl = environment === 'local'
  ? (import.meta.env.VITE_BOT_START_URL_LOCAL || 'http://localhost:7860/start')
  : (import.meta.env.VITE_BOT_START_URL_CLOUD || 'https://api.pipecat.daily.co/v1/public/{agentName}/start');

const botStartPublicApiKey = import.meta.env.VITE_BOT_START_PUBLIC_API_KEY;

// if (!import.meta.env.VITE_BOT_START_URL) {
//   console.warn(
//     'VITE_BOT_START_URL not configured, using default: http://localhost:7860/start'
//   );
// }
// // Log what we're actually using
// console.log('üîß Bot config:', {
//   environment,
//   botStartUrl,
//   hasApiKey: !!botStartPublicApiKey
// });
const dailyConfig = {
  endpoint: botStartUrl,
  requestData: {
    createDailyRoom: true,
    dailyRoomProperties: { start_video_off: true },
  },
};

if (botStartPublicApiKey) {
  dailyConfig.headers = new Headers({
    Authorization: `Bearer ${botStartPublicApiKey}`,
  });
}

const smallWebRTCConfig = {
  endpoint: botStartUrl,
  requestData: {
    createDailyRoom: false,
    enableDefaultIceServers: true,
  },
};

if (botStartPublicApiKey) {
  smallWebRTCConfig.headers = new Headers({
    Authorization: `Bearer ${botStartPublicApiKey}`,
  });
}

export const TRANSPORT_CONFIG = {
  daily: dailyConfig,
  smallwebrtc: smallWebRTCConfig,
};

/**
 * Create a transport instance based on the transport type
 * Uses dynamic imports to only load the required transport library
 */
export async function createTransport(transportType, userInfo = {}) {
  switch (transportType) {

    case 'daily': {
      const { DailyTransport } = await import('@pipecat-ai/daily-transport');
      
      const headers = {
        'Content-Type': 'application/json',
      };
      
      if (botStartPublicApiKey) {
        headers['Authorization'] = `Bearer ${botStartPublicApiKey}`;
      }
      
      const response = await fetch(dailyConfig.endpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          createDailyRoom: true,
          body: {
            name: userInfo.name,
            email: userInfo.email,
          }
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Backend error:', errorText);
        throw new Error(`Failed to start bot: ${response.statusText}`);
      }

      const responseData = await response.json();
      console.log('‚úÖ Backend response:', responseData);
      
      const { dailyRoom, dailyToken } = responseData;
      
      
      if (!dailyRoom || !dailyToken) {
        console.error('‚ùå Missing dailyRoom or dailyToken:', responseData);
        throw new Error('Backend did not return dailyRoom or dailyToken');
      }
      
      console.log('üîß Creating Daily transport with room:', dailyRoom);
      
      // ‚úÖ Create transport with config object (per documentation)
      return new DailyTransport({
        url: dailyRoom,           // Daily room URL
        token: dailyToken,        // Daily token
        userName: userInfo.name || "Guest", // User name
        audioSource: true,        // Enable microphone
        videoSource: false,       // Disable camera
        bufferLocalAudioUntilBotReady: true, // Wait for bot before playing audio
      });
    }

    case 'smallwebrtc': {
      const { SmallWebRTCTransport } = await import('@pipecat-ai/small-webrtc-transport');
      
      // ‚úÖ For SmallWebRTC, pass body in the config
      const smallWebRTCConfigWithUserInfo = {
        ...smallWebRTCConfig,
        config: {
          ...smallWebRTCConfig.config,
          body: {
            name: userInfo.name,
            email: userInfo.email,
          }
        }
      };
      
      console.log('üîß SmallWebRTC transport config:', smallWebRTCConfigWithUserInfo);
      return new SmallWebRTCTransport(smallWebRTCConfigWithUserInfo);
    }

    default:
      throw new Error(`Unsupported transport type: ${transportType}`);
  }
}
